#!/bin/bash

# ----------------------------- ITF Suite Hooks ------------------------------

# onSuiteBegin   'suitename'        : before all test cases in the suite
# onSuiteEnd     'suitename'        : after all test cases in the suite
# onTestLoad     'testname'         : after loading the parametrized test cases
# onTestRunBegin 'testname' 'params': before a test case setup function
# onTestRunEnd   'testname' 'params': after a test case teardown function
# onTestPass     'message'          : after a test passes
# onTestFail     'message'          : after a test fails

# ------------------------- ITF Suite Configuration ---------------------------

# If set to anything other than 0, ITF will only count the test cases
itf_cfg['core:dry_run']='false'
# If set, will output the test stdout to the terminal
itf_cfg['core:verbose']='true'
# The default buffer for the test stdout (cleared before every test)
itf_cfg['core:stdout']='/tmp/itf.out'

# --------------------------- ITF Suite Public API ----------------------------

itf_echo() {
    # Prints a message to the log and to the terminal if verbose is enabled
    #
    # Parameters:
    # $1: The message

    if [ ${itf_cfg['core:verbose']} == 'true' ]; then
        echo "$1" | tee -a ${itf_cfg['core:stdout']}
    else
        itf_log "$1"
    fi
}

itf_log() {
    # Log a message but does not print it to the terminal
    #
    # Parameters:
    # $1: The message

    echo "$1" >>${itf_cfg['core:stdout']}
}

itf_setup() {
    # Associate a setup function to a test function
    #
    # Usage:
    # itf_setup 'mytest' 'mysetup'
    #
    # Explanation:
    # Makes ITF call 'mysetup' before 'mytest' when executing test cases
    #
    # Use to:
    # Express common steps for different tests without code duplication
    #
    # Example:
    # itf_setup 'testOne' 'setupCommon'
    # itf_setup 'testTwo' 'setupCommon'

    if [ -z $1 ]; then
        echo '[ITF] Test function name cannot be empty' && exit 1
    fi
    if [ -z $2 ]; then
        echo '[ITF] Setup function name cannot be empty' && exit 1
    fi

    _itf_setup[$1]=$2
}

itf_teardown() {
    # Associate a teardown function to a test function
    #
    # Usage:
    # itf_teardown 'mytest' 'myteardown'
    #
    # Explanation:
    # Makes ITF call 'mysetup' after 'myteardown' when executing test cases
    #
    # Use to:
    # Express common steps for different tests without code duplication
    #
    # Example:
    # itf_teardown 'testOne' 'teardownCommon'
    # itf_teardown 'testTwo' 'teardownCommon'

    if [ -z $1 ]; then
        echo '[ITF] Test function name cannot be empty' && exit 1
    fi
    if [ -z $2 ]; then
        echo '[ITF] Teardown function name cannot be empty' && exit 1
    fi

    _itf_teardown[$1]=$2
}

itf_fixture() {
    # Associate a setup and teardown function to a test function
    #
    # Usage:
    # itf_fixture 'mytest' 'mysetup' 'myteardown'
    #
    # Explanation:
    # See itf_setup and itf_teardown
    #
    # Example:
    # itf_fixture 'testOne' 'setupCommon' 'teardownCommon'
    # itf_fixture 'testTwo' 'setupCommon' 'teardownCommon'

    itf_setup $1 $2
    itf_teardown $1 $3
}

itf_case() {
    # Adds a test case using a parametrized function and a set of parameters
    #
    # Usage:
    # itf_case 'myfunction' '--arg1=val1' '--arg2=val2' ...
    #
    # Explanation:
    # Registers the 'myfunction' as a test function in ITF, if not already.
    # Then, saves the arguments for later usage to invoke the function.
    # This effectively creates a suite of cases for the specific test function.
    #
    # Example
    # itf_case a_must_be_2 --a=2
    # itf_case a_must_be_3 --a=3
    # itf_case a_must_not_be_2 --a=3
    # itf_case a_must_not_be_2 --a=4

    if [ -z $1 ]; then
        echo "[ITF] Test function name cannot be empty" && exit 1
    fi

    if [ -z "${_itf_cases[$1]}" ]; then
        _itf_cases[$1]="${@:2}"
    else
        _itf_cases[$1]="${_itf_cases[$1]}${_itf_sep}${@:2}"
    fi
    let itf_state['ntests']=${itf_state['ntests']}+1
    let itf_state["${1}_ntests"]=${itf_state["${1}_ntests"]}+1
}

# --------------------------- ITF Suite Private API ---------------------------

# Read-only associative array with status about the suite after execution
#
# Array keys for suite summary:
#
# - name: The fixture name
# - ntests: The test count in the suite
# - passed: The amount of tests that passed
# - failed: The amount of tests that failed
#
# Array keys per test function:
#
# - [test_function]_ntests: The test count for the specific function
# - [test_function]_passed: The amount of tests that passed for a function
# - [test_function]_failed: The amount of tests that failed for a function
#
# Internal ITF Array keys:
#
# - modules: The ITF modules loaded by this suite
declare -A itf_state=()

# Test case parameters
declare -A _itf_cases=()
# Setup functions
declare -A _itf_setup=()
# Teardown functions
declare -A _itf_teardown=()

itf_run_suite() {

    # Clear ITF Suite variables state
    _itf_cases=()
    _itf_setup=()
    _itf_teardown=()
    itf_state=()
    itf_state['ntests']=0
    itf_state['failed']=0
    itf_state['passed']=0

    # Import the suite definitions
    itf_state['name']=$(basename $1)
    source $1

    itf_hook_publish 'onSuiteBegin' ${itf_state['name']}

    # If this is a dry-run, do not execute any tests
    if [ ${itf_cfg['core:dry_run']} == 'true' ]; then
        itf_hook_publish 'onSuiteEnd' ${itf_state['name']}
        return 0
    fi

    # Iterate on every test function registered
    for atest in ${!_itf_cases[@]}; do

        # Get an array of test cases associated with this test function name
        IFS="$_itf_sep" read -r -a tcases <<<"${_itf_cases[$atest]}"

        itf_hook_publish 'onTestLoad' $atest

        # Iterate on every test case
        for acase in "${tcases[@]}"; do
            # Get test case arguments as an array separated by spaces
            IFS=" " read -r -a args <<<"$acase"

            itf_hook_publish 'onTestRunBegin' $atest ${args[@]}

            # Setup
            if [ ! -z "${_itf_setup[$atest]}" ]; then
                ${_itf_setup[$atest]}
            fi

            # Invoke the test with the correct arguments
            ($atest ${args[@]})
            local retval=$?

            # Teardown
            if [ ! -z "${_itf_teardown[$atest]}" ]; then
                ${_itf_teardown[$atest]}
            fi

            itf_hook_publish 'onTestRunEnd' $atest ${args[@]}

            if [ $retval -eq 0 ]; then
                let itf_state['passed']=${itf_state['passed']}+1
                let itf_state["${atest}_passed"]=${itf_state["${atest}_passed"]}+1
                itf_hook_publish 'onTestPass' $itf_assertion_msg
            else
                let itf_state['failed']=${itf_state['failed']}+1
                let itf_state["${atest}_failed"]=${itf_state["${atest}_failed"]}+1
                itf_hook_publish 'onTestFail' $itf_assertion_msg
            fi
        done
    done

    # Teardown the suite functions
    for atest in ${!_itf_cases[@]}; do
        unset $atest ${_itf_setup[$atest]} ${_itf_teardown[$atest]}
    done
    unset tcases args
    itf_hook_publish 'onSuiteEnd' ${itf_state['name']}
}
