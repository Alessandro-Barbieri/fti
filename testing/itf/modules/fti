#!/bin/bash

# ------------------------- FTI Module Configuration --------------------------

# The number of ranks used for the mpirun command
itf_cfg['fti:nranks']=16
# If FTI module messages should be sent to the terminal
itf_set_if_undef 'fti:verbose' 'true'
# If FTI module messages should be sent to ITF logs
itf_set_if_undef 'fti:verbose_log' 'true'
# If FTI application stdout should be sent to terminal
itf_set_if_undef 'fti:verbose_app' 'false'
# The stdout for MPI test applications filename
itf_set_if_undef 'fti:app_stdout' '/tmp/itf_fti_app.out'
# The FTI configuration template file 
itf_set_if_undef 'fti:config_template' @fti_cfg_template@
# The FTI configuration file name used for FTI test cases
itf_set_if_undef 'fti:config' '/tmp/configfile.cfg'
# A Flag to keep the checkpoint directory after running the checks
itf_set_if_undef 'fti:keep_ckpt_dir' 'false'

# --------------------------- FTI Public Constants ----------------------------

# A list with all FTI available IO libraries
export fti_io_ids=(@fti_io_ids@)
# A list will all FTI available checkpoint levels
export fti_levels=(1 2 3 4)

# ----------------- FTI Public Configuration File Handling API ----------------

fti_config_get() {
    # Get the value of an FTI configuration field
    #
    # Parameters:
    # $1: The field name in the configuration file

    echo "$(awk -v f="$1" '$1 ~ f {print $3}' <${itf_cfg['fti:config']})"
}

fti_config_set() {
    # Set the value of an FTI configuration variable
    #
    # Parameters:
    # $1: The field name in the configuration file
    # $2: The new value for the field

    sed -i "/$1/c\\$1 = $2" ${itf_cfg['fti:config']}
    
    fti_mod_log "fti_config_set $1=$2"
}

fti_config_set_inline() {
    # Set the inline fields in FTI configuration file to true

    fti_config_set 'inline_l2' '1'
    fti_config_set 'inline_l3' '1'
    fti_config_set 'inline_l4' '1'
}

fti_config_set_ckpts() {
    # Set the checkpoint intervals of FTI in the configuration file
    #
    # Parameters:
    # $1-4: [Optional] The checkpoint interval for a level

    for i in ${fti_levels[@]}; do
        if [ ! -z ${!i} ]; then
            fti_config_set "ckpt_l$i" "${!i}"
        fi
    done
}

# ---------------------------- Application run API ----------------------------

fti_run() {
    # Executes an MPI application and propagates it's return value
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters
    #
    # Warning:
    # mpirun reads from stdin.
    # It makes it impossible to run mpirun while a file is open in stdin.
    # This breaks the loop as mpirun consumes the whole file contents as input.
    # To circunvent this, we redirect mpirun stdin to /dev/null
    # If this ever needs to be changed, the testrunner will need a rework.
    # Otherwise, the suite file will be consumed by mpirun.

    local fti_cmd="mpirun $MPIRUN_ARGS -n ${itf_cfg['fti:nranks']}"
    local app_stdout="${itf_cfg['fti:app_stdout']}"
    local test_stdout="${itf_cfg['core:stdout']}"

    fti_mod_log "fti_run: $fti_cmd $@"

    if [ ${itf_cfg['fti:verbose_app']} == 'true' ]; then
        $fti_cmd $@ | tee $app_stdout
        local _retval=${PIPESTATUS[0]}
    else
        $fti_cmd $@ > $app_stdout
        local _retval=$?
    fi
    itf_log "$(cat $app_stdout)"

    fti_mod_log "returns $_retval"
    return $_retval
}

fti_run_success() {
    # Run an MPI application and fail the test if the app returns non-zero
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters

    fti_run $@
    check_is_zero $? "Test app failure exitcode=$?"
}

# ------------------------- Checkpoint Corruption API -------------------------

ckpt_erase_last() {
    # Erase checkpoint objects from the last application executed with app_run
    #
    # Parameters:
    #
    # $1: Which checkpoint object to erase
    #       values: [ 'global', 'ckpt', 'partner', 'rs-encoding', 'node' ]
    # $@: which nodes to disrupt (only for local and IO is not MPI or SION)
    #       values: node directory names
    #
    # Usage Details:
    #
    # See 'find_fti_objects' usage details to see which files are deleted.

    itf_log "$itf_log_step" "checkpoint_erase $@"
    for f in $(find_fti_objects $@); do
        itf_log "$itf_log_step" "erased: $f"
        rm -rf $f
    done
}

ckpt_corrupt_last() {
    # Corrupt checkpoint objects from the last application executed with app_run
    #
    # Parameters:
    #
    # $1: Which checkpoint object to corrupt
    #       values: [ 'global', 'ckpt', 'partner', 'rs-encoding', 'node' ]
    # $@: which nodes to disrupt (only for local and IO is not MPI or SION)
    #       values: integers
    #
    # Usage Details:
    #
    # See 'find_fti_objects' usage details to see which files are deleted.
    
    itf_log "$itf_log_step" "checkpoint_corrupt $@"
    for f in $(find_fti_objects $@); do
        echo 'corruption' | dd conv=notrunc of=$f bs=1 >/dev/null 2>&1
        itf_log "$itf_log_step" "corrupted: $f"
    done
}

# ------------------------- FTI Private Internal API --------------------------

fti_mod_log() {
    # Logs an FTI module message according to the module configuration
    #
    # Parameters:
    # $1: The message to be logged

    if [ ${itf_cfg['fti:verbose']} == 'true' ]; then
        itf_echo "$1"
    elif [ ${itf_cfg['fti:verbose_log']} == 'true' ]; then
        itf_log "$1"
    fi
}

find_fti_objects() {
    # Find checkpoint objects from last ITF-managed execution (app_run*)
    #
    # Parameters:
    #
    # $1: Which checkpoint object to find
    #       values: [ 'global', 'ckpt', 'partner', 'rs-encoding', 'node' ]
    # $@: which nodes to delete, for local, if IO is not MPIIO or SIONLIB
    #       values: node names
    #
    # Usage Details:
    #
    # When the object is 'global' returns:
    # - The L4 directory in the FTI Global archive
    # When the object is 'ckpt' returns:
    # - First local checkpoint file, in a given level, for every supplied node
    # When the object is 'partner' returns:
    # - First local partner file, in a given level, for every supplied node
    # When the object is 'rs-encoding' returns:
    # - First local RS-encoding, in a given level, for every supplied node
    # When the object is 'node' returns:
    # - Local node directory for every supplied node

    if [ ! $1 == 'global' ] && [ -z $level ]; then
        fail '$level variable must be set for ITF to delete checkpoint files'
    fi

    local _id=$(fti_config_get 'exec_id')
    local _erase_all='false'

    # Switch action depending on the checkpoint object suppllied
    case $1 in
    global)
        # When deleting from global, delete everything
        echo "$(fti_config_get 'glbl_dir')/$_id/l4"
        return 0
        ;;
    ckpt)
        local _what='Rank'
        ;;
    partner)
        local _what='Pcof'
        ;;
    rs-encoding)
        local _what='RSed'
        ;;
    node)
        # When erasing the node, we delete all local information
        _erase_all='true'
        ;;
    *)
        fail "checkpoint object type malformed $1, try one of the following: 'global', 'ckpt', 'partner' or 'rs-encoding', 'node'"
        ;;
    esac
    shift

    local _where="$(fti_config_get 'ckpt_dir')"
    local _files=""
    for i in $@; do
        if [ $_erase_all == 'true' ]; then
            _files="$_files $_where/$i"
        else
            _files="$_files $(find $_where/$i/$_id/l$level | grep "$_what" | head -n 1)"
        fi
    done
    echo "$_files"
}

# ----------------------------- ITF Module Body -------------------------------

itf_hook_subscribe 'onTestRunBegin' 'copy_fti_config'
itf_hook_subscribe 'onTestRunBegin' 'clear_applog_buffer'
itf_hook_subscribe 'onTestRunEnd' 'remove_ckpt_dir'
itf_hook_subscribe 'onTestRunEnd' 'clear_applog_buffer'

copy_fti_config() {
    # Copy the FTI configuration file template

    cp ${itf_cfg['fti:config_template']} ${itf_cfg['fti:config']}
}

clear_applog_buffer() {
    # Clears the application log buffer before executing the test

    rm -rf ${itf_cfg['fti:app_stdout']}
}

remove_ckpt_dir() {
    # Removes the checkpoint directory in FTI configuration file
    if [ ${itf_cfg[fti:keep_ckpt_dir]} == 'true' ]; then
        local ckpt=$(fti_config_get 'ckpt_dir')
        local meta=$(fti_config_get 'meta_dir')
        local glbl=$(fti_config_get 'glbl_dir')

        rm -rf $ckpt $meta $glbl
    fi

}

fti_unload() {
    # FTI variables
    unset fti_io_ids fti_levels
    # FTI module logging functions
    unset fti_mod_log
    # FTI configuration file handling functions
    unset fti_config_get
    unset fti_config_set fti_config_set_ckpts fti_config_set_inline
    # FTI run application functions
    unset fti_run fti_run_success

    # FTI integration hooks functions
    unset copy_fti_config remove_ckpt_dir clear_applog_buffer

    # Unsubscribe from ITF event hooks
    itf_hook_unsubscribe 'onTestRunBegin' 'copy_fti_config'
    itf_hook_unsubscribe 'onTestRunBegin' 'clear_applog_buffer'
    itf_hook_unsubscribe 'onTestRunEnd' 'remove_ckpt_dir'
    itf_hook_unsubscribe 'onTestRunEnd' 'clear_applog_buffer'
}