#!/bin/bash

source $(dirname ${BASH_SOURCE[0]})/src/itf

# ---------------------------------- Colors -----------------------------------

declare -r COLOR_RESET='\033[0m'
declare -r COLOR_WHITEBOLD='\033[1m\033[37m'
declare -r COLOR_GREENBOLD='\033[1m\033[32m'
declare -r COLOR_REDBOLD='\033[1m\033[31m'
declare -r COLOR_BLUEBOLD="\033[1m\033[36m"
declare -r COLOR_MAGENTABOLD="\033[1m\033[35m"
declare -r COLOR_YELLOWBOLD="\033[1m\033[33m"

print_color() {
    # Prints a string in a different color
    #
    # Parameters:
    # $1: The color to use
    # $2: The string to be printed
    #
    # Warning:
    # If the string has spaces, the caller must use double quotes.
    # ex.: print_color "This is my testname"

    if [ ! -z ${cfg['no_colors']} ]; then
        printf "%b" "${@:2}"
    else
        printf "$1${@:2}$COLOR_RESET"
    fi
}

# ---------------------------- ITF Hook Listeners -----------------------------

declare -A driver_state=()
driver_state['nsuites']=0

suite_begin() {

    # Give it a line feed if this is not the first suite
    if [ ${driver_state['nsuites']} -gt 0 ]; then
        echo ""
    fi

    print_color $COLOR_WHITEBOLD "Suite: "
    print_color $COLOR_BLUEBOLD "$1"
    print_color $COLOR_WHITEBOLD " with "
    print_color $COLOR_YELLOWBOLD "${itf_state['ntests']}"
    print_color $COLOR_WHITEBOLD " tests.\n"

    let driver_state['nsuites']=${driver_state['nsuites']}+1
}

suite_end() {
    let summary['ntests']=${summary['ntests']}+${itf_state[ntests]}
    let summary['passed']=${summary['passed']}+${itf_state[passed]}
    let summary['failed']=${summary['failed']}+${itf_state[failed]}

    if [ ${itf_cfg['core:dry_run']} == 'true' ]; then
        return 0
    fi

    print_color $COLOR_WHITEBOLD "\n### Suite summary ###"
    print_color $COLOR_WHITEBOLD "\nExecuted: ${itf_state[ntests]}"
    print_color $COLOR_GREENBOLD "\nPassed:   ${itf_state[passed]}"
    print_color $COLOR_REDBOLD "\nFailed:   ${itf_state[failed]}\n"
}

test_load() {
    driver_state['test_name']="$1"
    driver_state['test_id']=1
    driver_state['test_max']=${itf_state["$1_ntests"]}

    print_color $COLOR_WHITEBOLD "\nFunction: "
    print_color $COLOR_MAGENTABOLD "${driver_state['test_name']}"
    print_color $COLOR_WHITEBOLD " with "
    print_color $COLOR_YELLOWBOLD "${driver_state['test_max']}"
    print_color $COLOR_WHITEBOLD " tests.\n\n"
}

test_case() {
    print_color $COLOR_WHITEBOLD "+ Test "
    print_color $COLOR_MAGENTABOLD "${itf_state[suite_name]}"
    print_color $COLOR_WHITEBOLD ":${driver_state['test_name']} "
    print_color $COLOR_WHITEBOLD "(${driver_state['test_id']}/${driver_state['test_max']}) "

    for param in ${@:2}; do

        local name=${param%=*}
        local val=${param#*=}
        name=${name#*--}

        print_color $COLOR_BLUEBOLD "$name"
        print_color $COLOR_WHITEBOLD "=$val "
    done
    printf "\n"
    let driver_state['test_id']=${driver_state['test_id']}+1
}

test_pass() {
    # Prints a message in green to notify that a test passed

    print_color $COLOR_GREENBOLD "[Passed]"
    if [ $# -gt 0 ]; then
        print_color $COLOR_GREENBOLD ":"
        while [ $# -gt 0 ]; do
            print_color $COLOR_GREENBOLD " $1"
            shift
        done
    fi
    printf '\n'
}

test_fail() {
    # Prints a message in red to notify that a test failed

    print_color $COLOR_REDBOLD "[Failed]"
    if [ $# -gt 0 ]; then
        print_color $COLOR_REDBOLD ":"
        while [ $# -gt 0 ]; do
            print_color $COLOR_REDBOLD " $1"
            shift
        done
    fi
    printf '\n'
}

# --------------------------- ITF Hook Registering ----------------------------

itf_hook_subscribe 'onSuiteBegin' 'suite_begin'
itf_hook_subscribe 'onSuiteEnd' 'suite_end'

itf_hook_subscribe 'onTestLoad' 'test_load'
itf_hook_subscribe 'onTestRunBegin' 'test_case'

itf_hook_subscribe 'onTestPass' 'test_pass'
itf_hook_subscribe 'onTestFail' 'test_fail'

# --------------------------- Test Runner Variables ---------------------------

declare -A summary=()
summary['ntests']=0
summary['passed']=0
summary['failed']=0

declare -A cfg=()

declare -a arguments=()
# Parse the command line outputs, extracts the relevant and maintain the rest
while [[ $# -gt 0 ]]; do
    case $1 in
    --path-modules)
        # Set the path to where ITF modules will be
        itf_cfg['core:module_path']=$2
        shift
        shift
        ;;
    --no-colors)
        # Disable the color output for the test driver
        cfg['no_colors']='true'
        shift
        ;;
    --verbose)
        # Activate all optional output from ITF and the FTI module
        itf_cfg['core:verbose']='true'
        itf_cfg['fti:verbose']='true'
        itf_cfg['fti:verbose_app']='true'
        shift
        ;;
    --quiet)
        # Shutdown any output to the terminal derived from ITF
        itf_cfg['core:verbose']='false'
        itf_cfg['fti:verbose']='false'
        itf_cfg['fti:verbose_app']='false'
        shift
        ;;
    --dry-run)
        # Only count the number of tests but do not execute them
        itf_cfg['core:dry_run']='true'
        shift
        ;;
    --ignore | -i)
        # Ignores functions with the given name in a given suite
        # Syntax is suite_name:function_name
        # Example: -i dCP:standard will ignore the standard function in dCP
        if [ ! -z ${itf_filter['whitelist']} ]; then
            echo "Cannot use both --ignore and --pick test case filters"
            exit 1
        fi
        itf_list_add 'itf_filter' 'blacklist' "$2"
        shift
        shift
        ;;
    --pick | -p)
        # Only execte functions with the given name in a given suite
        # Syntax is suite_name:function_name
        # Example: --pick dCP:standard will run the standard function in dCP
        if [ ! -z ${itf_filter['blacklist']} ]; then
            echo "Cannot use both --ignore and --pick test case filters"
            exit 1
        fi
        itf_list_add 'itf_filter' 'whitelist' "$2"
        shift
        shift
        ;;
    --filter | -f)
        # Filters out test cases from a test function in a suite by its parameters
        # Format: suite:test:param=v1,v2,v3
        # Behavior: ITF ignores cases of 'test' function, in 'suite', where 'param' is v1, v2 or v3
        itf_list_add 'itf_filter' "exclude:${2%=*}" "${2#*=}"
        shift
        shift
        ;;
    --revfilter | -r)
        # Only run test cases from a test function in a suite by its parameters
        # Format: suite:test:param=v1,v2,v3
        # Behavior: ITF run only cases of 'test' function, in 'suite', where 'param' is v1, v2 or v3
        # Details: revfilter is processed before filter
        itf_list_add 'itf_filter' "include:${2%=*}" "${2#*=}"
        shift
        shift
        ;;
    --all-logs)
        # Also keep the application logs for tests that passed
        itf_cfg['log:passed_cases']='true'
        shift
        ;;
    --no-logs)
        # Do not keep any ITF logs
        itf_cfg['log:passed_cases']='false'
        itf_cfg['log:failed_cases']='false'
        shift
        ;;
    -d | --maintain-ckpt-dir)
        # Keep the FTI checkpoint, global and meta directories after execution
        itf_cfg['fti:keep_ckpt_dir']='true'
        shift
        ;;
    -h | --help)
        # Prints a help message and exit
        # TODO
        exit 0
        ;;
    *)
        arguments+=($1)
        shift
        ;;
    esac
done

# --------------------------- Test Runner Procedure ---------------------------

for suite in ${arguments[@]}; do
    itf_run_suite $suite
done

if [ ${itf_cfg['core:dry_run']} == 'true' ]; then
    print_color $COLOR_WHITEBOLD "Total: "
    print_color $COLOR_YELLOWBOLD "${summary[ntests]}\n"
elif [ ${#arguments[@]} -gt 1 ]; then
    print_color $COLOR_WHITEBOLD "\n### Test Driver summary ###"
    print_color $COLOR_WHITEBOLD "\nSuites:   ${driver_state['nsuites']}"
    print_color $COLOR_WHITEBOLD "\nTests:    ${summary[ntests]}"
    print_color $COLOR_GREENBOLD "\nPassed:   ${summary[passed]}"
    print_color $COLOR_REDBOLD "\nFailed:   ${summary[failed]}\n"
fi

if [ ${summary[failed]} -ne 0 ] || [ ${summary[ntests]} -eq 0 ]; then
    exit 1
fi
