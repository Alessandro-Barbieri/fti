#!/bin/bash

declare_arguments() {
    # The standard tests with disruption tests FTI when its checkpoint files are corrupted
    #
    # Fixture-specific variables:
    # 
    # tamper: How to disrupt FTI checkpoint objects
    #   - erase: delete FTI objects (files or directories)
    #   - corrupt: corrupt FTI objects (adding or removing bytes)
    #
    # target: Which FTI object to tamper
    #   - node: local node directory
    #   - ckpt: checkpoint files
    #   - partner: local partner checkpoint files
    #   - rs-encoding: local RS encodings
    #   - global: global directory
    #
    # consecutive:
    #   - true: tamper with objects from consecutive node ids
    #   - false: tamper with objects from non-consecutive node ids 
    #
    # expected:
    #   - success: FTI is expected to succeed in this scenario
    #   - failure: FTI is expected to fail in this scenario

    itf_param_register_std 'iolib' 'level' 'icp' 'diffsize' 'head' 'keep'
    itf_param_register_fxt 'disrupt' 'target' 'consecutive' 'expected'
}

setup() {
    app='check.exe'
    fti_config_set_inline
}

runtest() {
    if [ $keep -eq 0 ]; then
        # Simulate a crash when not keeping last checkpoint
        app_run_success $app $itf_cfgfile 1 $level $diffsize $icp
    else
        # Run until the end when keeping last checkpoint
        app_run_success $app $itf_cfgfile 0 $level $diffsize $icp
    fi

    case $consecutive in
    true)
        ckpt_${disrupt}_last "$target" 'node0' 'node1'
        ;;
    irrelevant)
        ckpt_${disrupt}_last "$target"
        ;;
    *)
        ckpt_${disrupt}_last "$target" 'node0' 'node2'
        ;;
    esac

    app_run_timeout $app $itf_cfgfile 0 $level $diffsize $icp
    local retv=$?

    if [ $expected == 'success' ]; then
        assert_equals $retv 0 'FTI should succeed in the informed scenario'
    else
        assert_not_equals $retv 0 'FTI should fail in the informed scenario'
    fi
}

teardown() {
    unset app
}