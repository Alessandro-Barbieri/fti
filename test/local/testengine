#!/bin/bash
# ----------------------------- Engine Variables ------------------------------

declare -r COLOR_RESET='\033[0m'
declare -r COLOR_WHITEBOLD='\033[1m\033[37m'
declare -r COLOR_GREENBOLD='\033[1m\033[32m'
declare -r COLOR_REDBOLD='\033[1m\033[31m'

declare -r CFG_MOCK='fti_cfg_mock.cfg'

# itf_nranks: the rank count for the FTI test application
if [ -z $itf_nranks ]; then
    itf_nranks=16
fi

# itf_timeout: timeout to interrupt a test running with 'test_interrupt'
if [ -z $itf_timeout ]; then
    itf_timeout=30
fi

# itf_maintain_app_logs: flag to keep the application logs despite test result
if [ -z $itf_maintain_app_logs ]; then
    itf_maintain_app_logs=1
fi

# itf_cfgfile: the name of the config file used for every FTI test case
if [ -z $itf_cfgfile ]; then
    itf_cfgfile="/tmp/configfile"
fi

# itf_tstdout: standard output for FTI test applications
if [ -z $itf_tstdout ]; then
    itf_tstdout="/tmp/fti-test.log"
fi

# -------------------------- Engine Variable Setters --------------------------

engine_set_timeout() {
    # Set the timeout variable for the test engine
    #
    # Parameters:
    # $1: An integer representing the timeout in seconds
    #
    # Exception:
    # The value in seconds must be greater or equal to 10

    if [[ $1 -lt "10" ]] || [[ $1 == -* ]]; then
        echo -e "Wrong argument for timeout: "$1
        echo -e "usage: [command] -t <integer -ge 10>"
        exit 0
    fi
    itf_timeout="$1"
    echo "[OPTION] Set timeout -> "$itf_timeout
}

engine_set_keep_logs() {
    # Set the flag to keep test application logs even when they are successful

    itf_maintain_app_logs=0
}

# -------------------------- Fixture Setup Helpers ----------------------------

iolib_name_to_id() {
    # Echo the FTI id associated to a IO library name
    #
    # Parameters:
    # $1: The IO library name
    #
    # Returns:
    # 1 if the name is not recognized by FTI

    if [ "$1" = "POSIX" ]; then
        echo '1'
    elif [ "$1" = "MPIIO" ]; then
        echo '2'
    elif [ "$1" = "FTIFF" ]; then
        echo '3'
    elif [ "$1" = "SIONLIB" ]; then
        echo '4'
    elif [ "$1" = "HDF5" ]; then
        echo '5'
    else
        return 1
    fi
}

iolib_id_to_name() {
    # Echo the IO library name associated to an FTI id
    #
    # Parameters:
    # $1: The FTI id for the IO library
    #
    # Returns:
    # 1 if the id is not recognized by FTI

    if [ "$1" = 1 ]; then
        echo 'POSIX'
    elif [ "$1" = 2 ]; then
        echo 'MPIIO'
    elif [ "$1" = 3 ]; then
        echo 'FTIFF'
    elif [ "$1" = 4 ]; then
        echo 'SIONLIB'
    elif [ "$1" = 5 ]; then
        echo 'HDF5'
    else
        return 1
    fi
}

fti_config_get() {
    # Get the value of an FTI config field
    #
    # Parameters:
    # $1: The field name in the configuration file

    echo "$(awk -v f="$1" '$1 ~ f {print $3}' <$itf_cfgfile)"
}

fti_config_set() {
    # Set the value of an FTI config field
    #
    # Parameters:
    # $1: The field name in the configuration file
    # $2: The new value for the field

    echo "$(awk -v find="$1" -v swap="$2" '$1 ~ find {$3 = swap}1' $itf_cfgfile)" >$itf_cfgfile
}

fti_config_set_inline() {
    # Set FTI to perform the checkpoints inline

    fti_config_set 'inline_l2' '1'
    fti_config_set 'inline_l3' '1'
    fti_config_set 'inline_l4' '1'
}

# --------------------------- Fixture Test Helpers ----------------------------

app_run() {
    # Executes an MPI application
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters
    #
    # Warning:
    # mpirun reads from stdin.
    # It makes it impossible to run mpirun in a while loop reading a file.
    # This breaks the loop as mpirun consumes the whole file contents as input.
    # To circunvent this, we redirect stdin to /dev/null
    # If this ever needs to be changed, modify the behavior of the testrunner.
    # Otherwise, only the first test case will be executed from a suite.
    (
        set -x
        mpirun $MPIRUN_ARGS -n $itf_nranks $@ &>>$itf_tstdout </dev/null
    )
}

app_run_interrupt() {
    # Executes an MPI application and kill it after timeout seconds
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters

    (
        local __pid=$BASHPID
        (
            sleep $itf_timeout
            kill $__pid >/dev/null 2>&1
        ) &
        app_run $@
    )
}

ckpt_delete_global() {
    # Delete N checkpoint files from the current config file global directory
    #
    # Parameters:
    # $1: The amount of files to destroy
    # $2: The checkpoint level prepended with 'l'
    (
        IFS='
'
        local __global_dir="$(fti_config_get 'glbl_dir')"
        local __check_id="$(fti_config_get 'exec_id')"
        local __folder=$__global_dir/$__check_id/$1
        for f in $(ls $__folder | grep 'Rank\|mpiio\|sionlib' | head -n $2); do
            (
                set -x;
                rm -rf "$__folder/$f"
            )
        done
    )
}

pass() {
    # Force success in a test
    #
    # Parameters:
    # $1: An optional message to show

    print_color "$COLOR_GREENBOLD Passed ($1)\n"
    return 0
}

fail() {
    # Force failure in a test
    #
    # Parameters:
    # $1: An optional message to be printed

    if [ $# -eq 1 ]; then
        print_color "$COLOR_REDBOLD Failed because: $1\n"
    else
        print_color "$COLOR_REDBOLD Failed\n"
    fi
    return 1
}

assert_equals() {
    # Check if a numerical value is equal to another numerical value
    #
    # Parameters:
    # $1: The first numerical value
    # $2: Another numerical value
    # $3: An optional message in case of failure
    if [ $1 -eq $2 ]; then
        pass
        return $?
    fi
    fail "$3"
    return $?
}

assert_not_equals() {
    # Check if a numerical value is different to another
    #
    # Parameters:
    # $1: The first numerical value
    # $2: Another numerical value
    # $3: An optional message in case of failure

    if [ $1 -ne $2 ]; then
        pass
        return $?
    fi
    fail "$3"
    return $?
}

# -------------------------- Test Runner Functions ----------------------------

get_fixture_fail_log_name() {
    # Get the log filename to store the stdout of failure cases
    #
    # Warning:
    # This function will only work after sourcing a fixture script

    echo "$(shortname)-failed.log"
}

get_fixture_log_name() {
    # Get the log filename to store the stdout when maintaining logs
    #
    # Warning:
    # This function will only work after sourcing a fixture script

    echo "$(shortname).log"
}

test_case() {
    # Run a test defined in a fixture with a set of input data
    #
    # Parameters:
    # $@ The parameters to be passed to the fixture setup
    #
    # Returns:
    # Non-zero values if the test fails
    #
    # Detailed:
    # Run a test case until completion and checks if it failed.
    # If it fails, append the log into a file named after the test suite.

    cat "$CFG_MOCK" >$itf_cfgfile # create the configfile
    setup $@
    print_color $COLOR_WHITEBOLD "$(name)\n"
    runtest

    local __exitcode=$?
    if [ $__exitcode -ne 0 ]; then
        echo "$(name)" >>"$(get_fixture_fail_log_name)"
        cat $itf_tstdout >>"$(get_fixture_fail_log_name)"
    elif [ $itf_maintain_app_logs -eq 0 ]; then
        echo "$(name)" >>"$(get_fixture_log_name)"
        cat $itf_tstdout >>"$(get_fixture_log_name)"
    fi
    teardown
    rm -rf $itf_cfgfile
    rm -rf $itf_tstdout
    return $__exitcode
}

# ------------------------ Helpers for pretty printing ------------------------

print_color() {
    # Prints a string in a different color
    #
    # Parameters:
    # $1: The color to use
    # $2: The string to be printed
    #
    # Warning:
    # If the string has spaces, the caller must use double quotes.
    # ex.: print_color "This is my testname"

    printf "$1$2$COLOR_RESET"
}
