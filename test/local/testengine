#!/bin/bash
# ----------------------------- Engine Variables ------------------------------

declare -r COLOR_RESET='\033[0m'
declare -r COLOR_WHITEBOLD='\033[1m\033[37m'
declare -r COLOR_GREENBOLD='\033[1m\033[32m'
declare -r COLOR_REDBOLD='\033[1m\033[31m'
declare -r COLOR_BLUEBOLD="\033[1m\033[36m"
declare -r COLOR_MAGENTABOLD="\033[1m\033[35m"
declare -r COLOR_YELLOWBOLD="\033[1m\033[33m"

declare -r CFG_MOCK='fti_cfg_mock.cfg'

# itf_nranks: the rank count for the FTI test application
if [ -z $itf_nranks ]; then
    itf_nranks=16
fi

# itf_timeout: timeout to interrupt a test running with 'test_interrupt'
if [ -z $itf_timeout ]; then
    itf_timeout=30
fi

# itf_maintain_app_logs: flag to keep the application logs despite test result
if [ -z $itf_maintain_app_logs ]; then
    itf_maintain_app_logs=0
fi

# itf_maintain_ckpt: flag to keep the application checkpoint files after execution
if [ -z $itf_maintain_ckpt ]; then
    itf_maintain_ckpt=0
fi

# itf_cfgfile: the name of the config file used for every FTI test case
if [ -z $itf_cfgfile ]; then
    itf_cfgfile="/tmp/configfile"
fi

# itf_tstdout: standard output for FTI test applications
if [ -z $itf_tstdout ]; then
    itf_tstdout="/tmp/fti-test.log"
fi

# -------------------------- Runtime Variables --------------------------------

# itf_error: a buffer for error messages
itf_error=""
# itf_loaded_fixture: the currently loaded fixture in ITF
itf_loaded_fixture=""
# itf_testname: the current test case name
itf_testname=""

# -------------------------- Engine Variable Setters --------------------------

itf_set_testcase_name() {
    # Set the current test case name so that ITF can log it when executing
    #
    # Parameters:
    # $1: The test case name

    itf_testname="$1"
}

itf_set_timeout() {
    # Set the timeout variable for the test engine
    #
    # Parameters:
    # $1: An integer representing the timeout in seconds
    #
    # Exception:
    # The value in seconds must be greater or equal to 10

    if [[ $1 -lt "10" ]] || [[ $1 == -* ]]; then
        echo -e "Wrong argument for timeout: "$1
        echo -e "usage: [command] -t <integer -ge 10>"
        exit 0
    fi
    itf_timeout="$1"
    echo "[OPTION] Set timeout -> "$itf_timeout
}

itf_set_keep_ckpt() {
    # Set an engine to maintain all checkpoint files after test execution

    itf_maintain_ckpt=1
}

itf_set_keep_logs() {
    # Set the flag to keep test application logs even when they are successful

    itf_maintain_app_logs=1
}

# -------------------------- Fixture Setup Helpers ----------------------------

iolib_name_to_id() {
    # Echo the FTI id associated to a IO library name
    #
    # Parameters:
    # $1: The IO library name
    #
    # Returns:
    # 1 if the name is not recognized by FTI

    if [ "$1" = "POSIX" ]; then
        echo '1'
    elif [ "$1" = "MPIIO" ]; then
        echo '2'
    elif [ "$1" = "FTIFF" ]; then
        echo '3'
    elif [ "$1" = "SIONLIB" ]; then
        echo '4'
    elif [ "$1" = "HDF5" ]; then
        echo '5'
    else
        return 1
    fi
}

iolib_id_to_name() {
    # Echo the IO library name associated to an FTI id
    #
    # Parameters:
    # $1: The FTI id for the IO library
    #
    # Returns:
    # 1 if the id is not recognized by FTI

    if [ "$1" = 1 ]; then
        echo 'POSIX'
    elif [ "$1" = 2 ]; then
        echo 'MPIIO'
    elif [ "$1" = 3 ]; then
        echo 'FTIFF'
    elif [ "$1" = 4 ]; then
        echo 'SIONLIB'
    elif [ "$1" = 5 ]; then
        echo 'HDF5'
    else
        return 1
    fi
}

fti_config_get() {
    # Get the value of an FTI config field
    #
    # Parameters:
    # $1: The field name in the configuration file

    echo "$(awk -v f="$1" '$1 ~ f {print $3}' <$itf_cfgfile)"
}

fti_config_set() {
    # Set the value of an FTI config field
    #
    # Parameters:
    # $1: The field name in the configuration file
    # $2: The new value for the field
    # $3: If a third parameter is passed, this operation is verbose

    echo "$(awk -v find="$1" -v swap="$2" '$1 ~ find {$3 = swap}1' $itf_cfgfile)" >$itf_cfgfile
    if [ $# -gt 2 ]; then
        echo "+ fti_config_set $1=$2" | tee -a $itf_tstdout
    fi
}

fti_config_set_inline() {
    # Set FTI to perform the checkpoints inline
    #
    # Parameter:
    # $1: Any value passed will make the operation vervose

    fti_config_set 'inline_l2' '1' $1
    fti_config_set 'inline_l3' '1' $1
    fti_config_set 'inline_l4' '1' $1
}

# ----------------------- Fixture Parameter handling --------------------------

itf_manage_config_file() {
    # Set up the config file using ITF-standard variables
    #
    # Details:
    # This method can be called manually but will always be called when
    # a fixture contains a 'parameter' function definition

    if [ ! -z $iolib ]; then
        fti_config_set 'ckpt_io' "$iolib" 'verbose'
    fi
    if [ ! -z $head ]; then
        fti_config_set 'head' "$head" 'verbose'
    fi
    if [ ! -z $keep ]; then
        fti_config_set 'keep_last_ckpt' "$keep" 'verbose'
    fi
    if [ ! -z $level ] && [ $level -gt 1 ] && [ ! -z $head ] && [ $head -eq 0 ]; then
        fti_config_set "inline_l$level" '0' 'verbose'
    fi
}

itf_param_parse() {
    # Parse the parameters passed against the ones registered in ITF
    #
    # Parametes:
    # $@ The parameters to be parsed
    #
    # Usage:
    # Use this function after registering the parameters with either:
    # - param_register_itf
    # - param_register_custom
    #
    # This function will parse the parameters and setup variables acordingly
    #
    # Example:
    # param_register_itf 'iolib' 'head'
    # param_parse --iolib 1 --head 0
    # echo $iolib # should output 1
    # echo $head # should output 0

    # Define all variables from input parameters
    while [ $# -gt 1 ]; do
        itf_def_var_if_in_array $1 $2 ${itf_std_paramv[@]}
        if [ $? -ne 0 ]; then
            itf_def_var_if_in_array $1 $2 ${itf_fixt_paramv[@]}
            if [ $? -ne 0 ]; then
                itf_error="Invalid argument $1"
                return 1
            fi
        fi
        shift
        shift
    done

    # Check if all required standard variables were defined
    for p in "${itf_std_paramv[@]}"; do
        if [ -z ${!p} ]; then
            itf_error="Standard variable '$p' not found in test case: add [--$p val] to the suite"
            return 1
        fi
    done
    # Check if all required user variables were defined
    for p in "${itf_fixt_paramv[@]}"; do
        if [ -z ${!p} ]; then
            itf_error="User variable '$p' not assigned in test case: add [--$p val] to the suite"
            return 1
        fi
    done
}

itf_param_register_std() {
    # Register ITF-standard fixture parameters to be managed by ITF
    #
    # Parameters:
    # $@: Names recognized as ITF standard variables
    #
    # Details:
    # Check the ITF standard variables in the case clausules of function:
    # check_valid_itf_parameter
    #
    # Usage:
    # parameter_register_itf 'iolib' 'head' 'icp'
    # itf_param_parse --iolib 1 --head 0 --icp 1
    # echo $iolib

    while [ $# -gt 0 ]; do
        itf_std_paramv[$itf_std_paramc]=$1
        let itf_std_paramc=$itf_std_paramc+1
        shift
    done
}

itf_param_register_fxt() {
    # Register non ITF-standard fixture parameters to be managed by ITF
    #
    # Parameters:
    # $@: Names for the parameter variables
    #
    # Usage:
    # itf_param_register_fxt 'myparam' 'otherparam'
    # itf_param_parse --myparam 2 --otherparam 5
    # echo $myparam

    while [ $# -gt 0 ]; do
        itf_fixt_paramv[$itf_fixt_paramc]=$1
        let itf_fixt_paramc=$itf_fixt_paramc+1
        shift
    done
}

# --------------------------- Fixture Test Helpers ----------------------------

app_run() {
    # Executes an MPI application
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters
    #
    # Warning:
    # mpirun reads from stdin.
    # It makes it impossible to run mpirun in a while loop reading a file.
    # This breaks the loop as mpirun consumes the whole file contents as input.
    # To circunvent this, we redirect stdin to /dev/null
    # If this ever needs to be changed, modify the behavior of the testrunner.
    # Otherwise, only the first test case will be executed from a suite.

    (
        set -x
        mpirun $MPIRUN_ARGS -n $itf_nranks $@ &>>$itf_tstdout </dev/null
    )
}

app_run_success() {
    # Run an application and finalize the test case on failure if it fails
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters

    app_run $@
    check_is_zero $? "Test app failure exitcode=$?"
}

app_run_timeout() {
    # Executes an MPI application and kill if it exceeds $itf_timeout seconds
    #
    # Parameters:
    # $1: The path to the application binary
    # $@: The application's parameters

    (
        local __pid=$BASHPID
        (
            sleep $itf_timeout
            kill $__pid >/dev/null 2>&1
        ) &
        app_run $@
    )
}

ckpt_erase_last() {
    # Erase checkpoint objects from last ITF-managed execution (app_run*)
    #
    # Parameters:
    #
    # $1: Which checkpoint object to erase
    #       values: [ 'global', 'ckpt', 'partner', 'rs-encoding', 'node' ]
    # $@: which nodes to delete, only used for local objects if IO is not MPIIO or SIONLIB
    #       values: integers
    #
    # Usage Details:
    #
    # See 'itf_find_fti_objects' usage details to see which files are deleted.

    for f in "$(itf_find_fti_objects $@)"; do
        (
            set -x
            rm -rf $f
        )
    done
}

ckpt_corrupt_last() {
    # Corrupt checkpoint objects from last ITF-managed execution (app_run*)
    #
    # Parameters:
    #
    # $1: Which checkpoint object to corrupt
    #       values: [ 'global', 'ckpt', 'partner', 'rs-encoding', 'node' ]
    # $@: which nodes to delete, only used for local objects if IO is not MPIIO or SIONLIB
    #       values: integers
    #
    # Usage Details:
    #
    # See 'itf_find_fti_objects' usage details to see which files are deleted.

    for f in "$(itf_find_fti_objects $@)"; do
        (
            set -x
            printf "corruption" | dd conv=notrunc of=$f bs=1 >/dev/null 2>&1
        )
    done
}

ckpt_delete_global() {
    # Delete N checkpoint files from the current config file global directory
    #
    # Parameters:
    # $1: The amount of files to destroy
    # $2: The checkpoint level prepended with 'l'
    (
        IFS='
'
        local __global_dir="$(fti_config_get 'glbl_dir')"
        local __check_id="$(fti_config_get 'exec_id')"
        local __folder=$__global_dir/$__check_id/$1
        for f in $(ls $__folder | grep 'Rank\|mpiio\|sionlib' | head -n $2); do
            (
                set -x
                rm -rf "$__folder/$f"
            )
        done
    )
}

pass() {
    # Exit a test case successfully
    #
    # Parameters:
    # $1: An optional feedback message

    print_color $COLOR_GREENBOLD "Passed"
    if [ $# -eq 1 ]; then
        print_color $COLOR_GREENBOLD ": $1"
    fi
    printf '\n'
    exit 0
}

fail() {
    # Exit a test case in failure
    #
    # Parameters:
    # $1: An optional feedback message

    print_color $COLOR_REDBOLD "Failed"
    if [ $# -eq 1 ]; then
        print_color $COLOR_REDBOLD ": $1"
    fi
    printf '\n'
    exit 1
}

check_equals() {
    # Check if a value is equal to another and finalize test case if not equals
    #
    # Parameters:
    # $1: The first numerical value
    # $2: Another numerical value
    # $3: An optional message in case of failure

    if [ $1 -ne $2 ]; then
        fail "$3"
    fi
}

check_not_equals() {
    # Check if a value is not equal to another and finalize test case if equals
    #
    # Parameters:
    # $1: The first numerical value
    # $2: Another numerical value
    # $3: An optional message in case of failure

    if [ $1 -eq $2 ]; then
        fail "$3"
    fi
}

check_is_zero() {
    # Check if a value is equal to zero and finalize test case if different
    #
    # Parameters:
    # $1: The first numerical value
    # $2: An optional message in case of failure

    if [ $1 -ne 0 ]; then
        fail "$2"
    fi
}

check_non_zero() {
    # Check if a value is different to zero and finalize test case if equals
    #
    # Parameters:
    # $1: The first numerical value
    # $2: An optional message in case of failure

    if [ $1 -eq 0 ]; then
        fail "$2"
    fi
}

assert_equals() {
    # Assert if a value is equal to another and finalize test case
    #
    # Parameters:
    # $1: The first numerical value
    # $2: Another numerical value
    # $3: An optional message in case of failure

    check_equals $1 $2 $3
    pass
}

assert_not_equals() {
    # Assert if a value is equal to another and finalize test case
    #
    # Parameters:
    # $1: The first value
    # $2: Another value
    # $3: An optional message in case of failure

    check_not_equals $1 $2 $3
    pass
}

# -------------------------- Test Runner Functions ----------------------------

get_fixture_failure_log() {
    # Get the failure log filename for the current fixture

    echo "$itf_loaded_fixture-failed.log"
}

get_fixture_log() {
    # Get the log filename for the current fixture

    echo "$itf_loaded_fixture.log"
}

itf_load_fixture() {
    # Loads the function definitions in a fixture to the current context
    #
    # Parameters:
    # $1: The fixture name without the .fixture extension

    itf_loaded_fixture="$1"
    source "$1.fixture"

    # Erase the old logs so reports contain only the most recent data
    rm -rf "$(get_fixture_failure_log)"
    if [ $itf_maintain_app_logs -eq 1 ]; then
        rm -rf "$(get_fixture_log)"
    fi
}

itf_unload_fixture() {
    # Removes all definitions declared in a fixture
    # This should be called if the runner will execute another fixture

    unset declare_arguments
    unset setup
    unset runtest
    unset teardown

    type on_fixture_teardown &>/dev/null && on_fixture_teardown
    unset on_fixture_teardown
}

test_case() {
    # Run a test defined in a fixture with a set of input data
    #
    # Parameters:
    # $@ The parameters to be passed to the fixture setup
    #
    # Returns:
    # Non-zero values if the test fails
    #
    # Detailed:
    # Run a test case until completion and checks if it failed.
    # If it fails, append the log into a file named after the test suite.

    # Create the FTI configfile based on the mock
    cat "$CFG_MOCK" >$itf_cfgfile

    # Clear parameters from previous test case
    itf_param_clear
    # Get the arguments from the test fixture
    declare_arguments
    # Parse the test case arguments an ddefine variables
    itf_param_parse $@
    # Call the test case setup
    setup $@
    # Print feedback
    print_color $COLOR_YELLOWBOLD "$itf_testname\n"
    echo "$(itf_describe_test_case)"
    echo "$itf_testname" >> $itf_tstdout
    echo $(itf_describe_test_case_colorless) >> $itf_tstdout

    # Execute the test fixture
    (
        # Test if ITF has any error stored
        if [ ! -z "$itf_error" ]; then
            echo "$itf_error" >>$itf_tstdout
            fail "$itf_error"
        fi
        # If ITF is managing input parameters, setup the config file
        itf_manage_config_file
        # Run the test
        runtest
    )

    # Save logs if needed
    local __exitcode=$?
    local faillog="$(get_fixture_failure_log)"
    local normallog="$(get_fixture_log)"

    if [ $__exitcode -ne 0 ]; then
        cat $itf_tstdout >> $faillog
    elif [ $itf_maintain_app_logs -eq 1 ]; then
        cat $itf_tstdout >> $normallog
    fi

    # Call the test case teardown
    teardown
    # Releases any ITF-managed parameter variable names
    itf_param_unset

    # Remove the global, local and meta directories
    if [ $itf_maintain_ckpt -eq 0 ]; then
        local _locdir="$(fti_config_get 'ckpt_dir')"
        local _globaldir="$(fti_config_get 'glbl_dir')"
        local _metadir="$(fti_config_get 'meta_dir')"
        rm -rf $_locdir $_globaldir $_metadir
    fi

    # Remove the config files and test stdout
    rm -rf $itf_cfgfile $itf_tstdout

    return $__exitcode
}

# ------------------------ Helpers for pretty printing ------------------------

print_color() {
    # Prints a string in a different color
    #
    # Parameters:
    # $1: The color to use
    # $2: The string to be printed
    #
    # Warning:
    # If the string has spaces, the caller must use double quotes.
    # ex.: print_color "This is my testname"

    printf "$1$2$COLOR_RESET"
}

# --------------------------- ITF Interal functions ---------------------------

itf_describe_test_case() {
    # Describe the current test case in terms of its arguments and values

    for p in "${itf_std_paramv[@]}"; do
        print_color $COLOR_BLUEBOLD "$p="
        if [ $p == 'iolib' ]; then
            print_color $COLOR_WHITEBOLD "$(iolib_id_to_name $iolib) "
        else
            print_color $COLOR_WHITEBOLD "${!p} "
        fi
    done
    for p in "${itf_fixt_paramv[@]}"; do
        print_color $COLOR_BLUEBOLD "$p="
        print_color $COLOR_WHITEBOLD "${!p} "
    done
}

itf_describe_test_case_colorless() {
    # Same as itf_describe_test_case but without colors

    for p in "${itf_std_paramv[@]}"; do
        printf "$p="
        if [ $p == 'iolib' ]; then
            printf "$(iolib_id_to_name $iolib) "
        else
            printf "${!p} "
        fi
    done
    for p in "${itf_fixt_paramv[@]}"; do
        printf "$p=${!p} "
    done
}

itf_find_fti_objects() {
    # Find checkpoint objects from last ITF-managed execution (app_run*)
    #
    # Parameters:
    #
    # $1: Which checkpoint object to find
    #       values: [ 'global', 'ckpt', 'partner', 'rs-encoding', 'node' ]
    # $@: which nodes to delete, only used for local objects if IO is not MPIIO or SIONLIB
    #       values: integers
    #
    # Usage Details:
    #
    # When the object is 'global'
    # - List every file, in the global directory, in a given level
    # When the object is 'ckpt'
    # - Find the first local checkpoint file, in a given level, for every supplied node
    # When the object is 'partner'
    # - Find the first local partner checkpoint file, in a given level, for every supplied node
    # When the object is 'rs-encoding'
    # - Find the first RS encoding file in the local directory, in a given level, for every supplied node
    # When the object is 'node'
    # - Find the node directory in the local directory for every supplied node

    if [ -z $level ]; then
        fail '$level variable must be set for ITF to delete checkpoint files'
    fi

    local _id=$(fti_config_get 'exec_id')
    local _erase_all='false'

    # Switch action depending on the checkpoint object suppllied
    case $1 in
    global)
        # When deleting from global, delete everything
        echo "$(fti_config_get 'glbl_dir')/$_id/l$level/*"
        return 0
        ;;
    ckpt)
        local _what='Rank'
        ;;
    partner)
        local _what='Pcof'
        ;;
    rs-encoding)
        local _what='RSed'
        ;;
    node)
        # When erasing the node, we delete all local information
        _erase_all='true'
        ;;
    *)
        fail "checkpoint object type malformed $1, try one of the following: " \
            "'global', 'ckpt', 'partner' or 'rs-encoding', 'node'"
        ;;
    esac
    shift

    local _where="$(fti_config_get 'ckpt_dir')"
    local _files=""
    for i in $@; do
        if [ $_erase_all == 'true' ]; then
            _files="$_files $_where/$i"
        else
            _files="$_files $(find $_where/$i/$_id/l$level | grep "$_what" | head -n 1)"
        fi
    done
    echo "$_files"
}

itf_def_var_if_in_array() {
    # Define a variable with a given value if the name is found within a set
    #
    # Parameters:
    # $1: A parameter given to the test fixture setup method
    # $2: The value given to the parameter
    # $3+: A set of valid parameters names without the leading '--'

    for p in ${@:3}; do
        if [ $1 == "--$p" ]; then
            # TODO: Check if it has a valid value??
            eval $p=$2
            return 0
        fi
    done
    return 1
}

itf_param_clear() {
    # Clear the set of parameters managed by ITF

    itf_error=""
    itf_std_paramc=0
    itf_std_paramv=()
    itf_fixt_paramc=0
    itf_fixt_paramv=()
}

itf_param_unset() {
    # Unsets any parameter registered in the fixture as ITF-managed

    for i in ${itf_std_paramv[@]}; do
        unset $i
    done
    for i in ${itf_fixt_paramv[@]}; do
        unset $i
    done
}

# Declare the list of managed parameters
itf_param_clear
